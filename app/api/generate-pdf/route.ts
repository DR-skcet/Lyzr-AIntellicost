
import { type NextRequest, NextResponse } from "next/server"
// @ts-ignore
import PDFDocument from "pdfkit"
import { Readable } from "stream"

export async function POST(request: NextRequest) {
  try {
    const { result, formData, email } = await request.json();

    // Create a PDF document
    const doc = new PDFDocument({ margin: 40 });
    const chunks: Buffer[] = [];
    doc.on('data', (chunk: Buffer) => chunks.push(Buffer.from(chunk)));

    // Register and use a custom font (Roboto)
    const fontPath = process.cwd() + '/public/fonts/Roboto-Regular.ttf';
    doc.registerFont('roboto', fontPath);
    doc.font('roboto');


    // --- Professional Cover Page ---
    doc.addPage();
    doc.fontSize(28).fillColor('#222').text('AIntellicost', { align: 'center' });
    doc.moveDown(0.5);
    doc.fontSize(18).fillColor('#111').text('AI Cost Optimization Report', { align: 'center' });
    doc.moveDown(0.5);
    doc.fontSize(12).fillColor('#666').text('Empowering Smarter AI Investments', { align: 'center' });
    doc.moveDown(6);
    doc.fontSize(10).fillColor('#888').text('Confidential | Generated by AIntellicost', { align: 'center' });
    doc.addPage();

    // --- Main Content (sectioned, professional font/size) ---
    // Parse the result.response as markdown and split into sections by headings
    const markdown = result && result.response ? result.response : (result || 'No report data available.');
    const sections = markdown.split(/\n[#]+ |\n##+ |\n### /g).map((s: string) => s.trim()).filter(Boolean);

    // Add form summary at the top with spacing
    doc.fontSize(13).fillColor('#222').text('Summary', { underline: true });
    doc.moveDown(0.7);
    doc.fontSize(11).fillColor('#111');
    doc.text(`Business Domain: ${formData.domain}`);
    doc.moveDown(0.2);
    doc.text(`Team Size: ${formData.teamSize}`);
    doc.moveDown(0.2);
    doc.text(`Monthly Budget: $${formData.budget}`);
    doc.moveDown(0.2);
    doc.text(`Optimization Priority: ${formData.priority}`);
    doc.moveDown(0.2);
    doc.text(`Cloud Infrastructure: ${formData.infrastructure}`);
    doc.moveDown(0.2);
    doc.text(`Monthly Token Volume: ${formData.monthlyVolume}`);
    doc.moveDown(0.2);
    doc.text(`Current LLM Models: ${(formData.currentModels || []).join(', ') || 'N/A'}`);
    doc.moveDown(0.2);
    doc.text(`Organizational Functions: ${(formData.organizationalFunctions || []).join(', ') || 'N/A'}`);
    doc.moveDown(1);

    // Try to render tables for sections that look like tables
    const renderTable = (content: string) => {
      // Look for lines with tabs or multiple spaces (simulate table rows)
      const lines = content.split('\n').filter(l => l.trim());
      if (lines.length < 2) return false;
      // If header and at least one row have 2+ columns, treat as table
      const headerCols = lines[0].split(/\s{2,}|\t/);
      if (headerCols.length < 2) return false;
      doc.moveDown(0.3);
      // Header
      doc.fontSize(11).fillColor('#222').text(headerCols.join(' | '), { underline: true });
      // Rows
      for (let i = 1; i < lines.length; i++) {
        const cols = lines[i].split(/\s{2,}|\t/);
        doc.fontSize(10).fillColor('#111').text(cols.join(' | '));
      }
      doc.moveDown(0.5);
      return true;
    };

    // Sectioned content with more space and table rendering
    sections.forEach((section: string, idx: number) => {
      // Try to split section into title/content
      const lines = section.split("\n");
      let title = lines[0].replace(/[*_#]/g, '').trim();
      let content = lines.slice(1).join("\n").replace(/[*_#]/g, '').trim();
      if (!content) {
        content = title;
        title = `Section ${idx + 1}`;
      }
      doc.moveDown(0.7);
      doc.fontSize(13).fillColor('#345').text(title, { underline: true });
      doc.moveDown(0.3);
      // Try to render as table, else as text
      if (!renderTable(content)) {
        doc.fontSize(11).fillColor('#111').text(content);
      }
      doc.moveDown(0.7);
    });

    // --- Footer with page numbers ---
    const pageCount = doc.bufferedPageRange().count;
    for (let i = 0; i < pageCount; i++) {
      doc.switchToPage(i);
      doc.fontSize(8).fillColor('#888');
      doc.text(`AIntellicost | Page ${i + 1} of ${pageCount}`, 40, doc.page.height - 40, { align: 'center' });
    }

    doc.end();

    // Wait for PDF to finish
    await new Promise((resolve) => doc.on('end', resolve));
    const pdfBuffer = Buffer.concat(chunks);

    return new NextResponse(pdfBuffer, {
      headers: {
        "Content-Type": "application/pdf",
        "Content-Disposition": 'attachment; filename="AIntellicost_Report.pdf"',
      },
    });
  } catch (error) {
    console.error("PDF generation error:", error);
    return NextResponse.json({ error: "Failed to generate PDF" }, { status: 500 });
  }
}
